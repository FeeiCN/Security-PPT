Breaking Samsung's Root of Trust: Exploiting Samsung S10 S-Boot
Jeffxx
#BHUSA @BLACKHATEVENTS

Jeff Chao (Jeffxx)
 Researcher at Trapa Security  Ex-senior Researcher at TeamT5  Member of HITCON CTF Team  Member of Chroot
 Focus on Mobile and IoT Vulnerabilities

AGENDA
01 Demo 02 Related Work 03 Vulnerabilities in Secure Boot 04 Samsung Security Framework - Knox 05 After Code Execution on S-boot

Demo Video

Samsung Security Framework Knox

Knox - Root of Trust

Knox ­ Trusted Boot
 Hardware PBL  Verify secure boot(S-Boot) & load
 S-Boot  Set handler for Monitor mode, drop privilege  Request EL3 to initial TEEOS  Verify & Load Hypervisor (uh.bin)  Verify & Load Kernel (boot.img)
 Kernel with DM-Verity  Verify system.img & mount  Verify vendor.img & mount

Knox bit (warranty bit)
 One-time fuse, can't restore  Blow the fuse when trying to boot a custom image and prevent further booting

Sensitive Data Protection
 The storage (Sensitive Data) is encrypted when the device is locked  Encrypted Keys are stored in trustzone

Sensitive Data Protection cont
 Some critical information can only be decrypted by trustlet

ARM Trustzone

EL0

Non-secure World User Mode

EL1

Kernel Mode

EL2

Hypervisor Mode

EL3

Secure World User Mode Kernel Mode
Monitor Mode

Related Work

BH17 ­ Defeating Samsung KNOX

with zero privilege by returnsme
 EL0 -> EL1 (kinibi)

Non-secure World

Secure World

EL0

User Mode

User Mode

EL1

Kernel Mode

Kernel Mode

EL2

Hypervisor Mode

EL3

Monitor Mode

BH17 EU - How Samsung Secures
Your Wallet by Tencent Lab
 EL0 -> Secure EL0 (kinibi)

Non-secure World

Secure World

EL0

User Mode

User Mode

EL1

Kernel Mode

Kernel Mode

EL2

Hypervisor Mode

EL3

Monitor Mode

BH19 ­ Breaking Samsung's Arm
Trustzone
 EL0 -> Secure-EL3 (kinibi, S8 and before)

Non-secure World

Secure World

EL0

User Mode

User Mode

EL1

Kernel Mode

Kerne Mode

EL2

Hypervisor Mode

EL3

Monitor Mode

What if the device is turned off & we don't know the passcode?

In this talk
 out-side the box(locked phone) -> Non-Secure EL1

EL0

Non-secure World User Mode

EL1

SVC/Sys/Abort Mode

EL2

Hypervisor Mode

EL3

Secure World User Mode
SVC/Sys/Abort Mode
Monitor Mode

S-Boot Boot Flow
Set monitor mode Init
Check boot mode volumn down + power Verify boot image Boot into kernel

ODIN mode

ODIN mode
 Flash stock firmware  Rollback prevention

Vulnerability I

Odin Request
 opCode  0x64 Odin mode initial & settings  0x65 Flash PIT  0x66 Flag image
 subOp  Depends on opCode  Maybe initialize, set, get ...etc
 arg1 ~ arg4  assign size or some value

Odin Flash Image Command
 No check for provided size  Integer overflow
 Use 0xC0000000 if less then 0x1e00000  Otherwise use 0xB0000000
 Copy to buffer  S8 and before at 0xC0000000  S9 and later at 0x880000000

Overflow the physical memory

0xC0000000 buffer for flash image

0xC0000000
filled with null

0xC9000000

sboot code segment

sboot data sesgtamceknt

heap heap

0xC9000000
data overwritten

Bypass MMU
 S-Boot code segment at 0xC9000000 but read only  USB devices have direct memory access
 Ignores mmu control

Cache Incoherency
 While receiving data, the CPU keeps tracking the USB event  This code is cached
 Only the heap will not be cached

Code Execution
 The heap is not cached, the code accesses a pointer in the heap...  Trigger data-abort as soon as we overwrite heap data with NULL
 Overwrite the error handler code with jump sled  Put shellcode in front of the code segment

Overflow the physical memory

0xC0000000 buffer for flash image

0xC0000000
filled with null

0xC9000000

sboot code segment

sboot data sesgtamceknt

heap heap

shellcode
0xC9000000
modified sboot code segment
filled with null

But
 S9 and later are not exploitable  The default buffer is changed to 0x880000000  Spent half a year trying to exploit S10

Potential Exploit Path on S10
 In S9 and later, ODIN has parallel & compressed download mode  It will boot up another 2 cpu, and set the image buffer to 0x880000000  Fallback to normal download if boot cpu failure
 Buffer change back to 0xC0000000

Potential Exploit Path on S10
 Make CPU boot fails

Potential Exploit Path on S10
 Uart mode  Cmd ­ smp_test
 Test Boot up a cpu core and shutdown immediately  But count of booted cores will not decrease
 Cmd ­ download
 Enter Odin mode

Potential Exploit Path on S10
 Enter Uart Mode  We need a debug cable to make S-Boot detect RID_523K
 Tried TypeC VDM mode, accessory mode, pull-down pull-up resistor  All failed

We reported the bug on Aug 2019

Result: Duplicated

Patch Note
 Samsung Security Update - October 2019  SVE-2019-15230 Potential Integer overflow in Bootloader

The Patch

Vulnerability II

Aligned Size?

Odin - packet data size
 We can set packet data size with opCode 0x64, subOp 0x05

Exploit
 Bypass the check  The usb receive size can be larger than 0x10000000 again  Achieve code execution in the same way as the previous vulnerability

I reported the bug immediately

Patch Note
 Samsung Security Update - Jan 2020

The Patch

Vulnerability III

ODIN ­ PIT flash command
 opCode = 0x65  PIT is very small, odin store it to heap buffer
 With the size 0x2000

The patch of vulnerability II
 Size of packet data can be upto 0xFFFFFF  > 0x2000 => heap overflow

Pseudo code - receive data
 This is a pseudocode representation of the receive operation
 In our test, the usb_recv function will receive until the passed size is reached  Even if we send data with a huge interval

We thought this was un-exploitable, so I stuck to
vulnerability I

How About Interrupting the USB
 Remove and Re-insert the USB cable  the usb_recv returns with insufficient size

Heap overflow
 We can overwrite the metadata of heap chunk
 House of Spirit

Heap

size

unused

prev

next

data

size

unused

prev

next

data

size

unused

prev

next

data

Fake Chunk
No check for double linked list
faked chunk

size

unused

prev

next

data

size

unused

prev

next

data

size

unused

prev

next

data

Limited Overwrite Data

 *prev + 4 = 1  It aarch64, integer 64 bit
 Code at 0xC9000000  We can not point to
 Got  Function pointer

faked chunk

size

unused

prev

next

data

size

unused = 1

prev

next

data

size

unused

prev

next

data

Free

Overwrite RIP in stack Stack

 The only chance is to overwrite a return address on stack
 Only 3 function calls

 Fortunately  Odin cmd buf is the first local variable

size

unused

prev

next

data

SP PC local variable SP PC
local variable
Odin cmd buf
SP PC
local variable

Stack

SP PC
local variable
SP PC

local variable

size

unused

pSrePv

nPeCxt

localdvaatariable

After Code Execution in S-boot

Boot the phone

 We smashed the stack & heap  Hard to recover  Call the boot functions one by one

buffer for flash image

sboot code segment
sboot data sesgtamceknt
heap heap

filled with null
shellcode
modified sboot code
segment
filled with null

Skip Trustzone related call
 We only have EL1 privilege  Some smc call to trustzone can not call twice  Skip the smc call and set the related parameter

Load Custom Kernel
 After loading kernel to memory (the function cmd_load_kernel)  Replace the image with custom one  Booting the kernel (call the function cmd_boot)

Exploit
 Set the size of packet data to a big number  Send Odin PIT flash command  Send payload after Interrupt the usb_recv(), leads to heap overflow  Send Another Odin command to trigger malloc & free the buffer  Overwrite RIP on stack, jump to shellcode
 Re-init heap and stack  Continue booting  Before boot into kernel, replace the boot image

We got el1 in normal world

EL0 EL1 EL2 EL3

Non-secure World User Mode Kernel Mode
Hypervisor Mode

Secure World User Mode Kernel Mode
Monitor Mode

But the phone is still locked

Can not read sensitive data
 Storage is still encrypted if we didn't provide the screen passcode  Encryption key can only be decrypted in the gatekeeper trustlet
 Some data in trustlet can not be reached

Man in the Non-secure EL1

 Wait for the user to unlock the phone

 Hijack / Sniff everything between non-secure world and secure world

Non-secure World

EL0

User Mode

Secure World User Mode

EL1

Kernel Mode

Kernel Mode

EL2

Hypervisor Mode

EL3

Monitor Mode

Exposed Attacking surface

 Attacking secure world trustlet  Gatekeeper trustlet  Samsung Pay trustlet  Keystore trustlet ...
 Many vulnerabilities in the past

Non-secure World

EL0

User Mode

EL1

Kernel Mode

EL2

Hypervisor Mode

EL3

Secure World User Mode Kernel Mode
Monitor Mode

Attack the gatekeeper trustlet to decrypt storage
 SVE-2019-14575
 With this vulnerability, we can try all the possible pattern codes in a few hours.

Sensitive Data unlocked

Conclusion
 Even if the data is stored in secure world, it doesn't mean it's 100% secure  But it's made exploiting complex, multiple actions are needed to retrieve the data
 Landing - RCE / Local USB Exploit / Social Engineering  Privilege escalation to non-secure EL1  Vulnerabilities in trustlet to get into secure-world EL0  Privilege escalation from secure-world EL0 to secure-world EL1 or EL3  Without all of this, especially the points in red, the data in the phone is still safe

Disclosure Timeline
 2019-10-02 Report Vulnerability I  2019-10-08 Informed Vulnerability I duplicated  2019-10-11 Report Vulnerability II  2020-01-06 Samsung Patched, SVE-2019-15872  2020-01-21 Report Vulnerability III  2020-05-06 Samsung Patched, SVE-2020-16712

THANK YOU!
Jeffxx jeffxx@trapa.tw

