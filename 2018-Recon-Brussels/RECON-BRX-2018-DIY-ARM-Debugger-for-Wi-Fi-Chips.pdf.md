DIY ARM Debugger for Wi-Fi Chips
Using Nexmon to Perform Single-Step Debugging and More on Proprietary Wi-Fi Chips
Matthias Schulz

Broadcom FullMAC

Wi-Fi Chips

Nexus 5

ARM Cortex-R4

Assembly

Hardware Debugger
Breakpoints

Memory Watchpoints

Exception Handling

Operation Modes

Frame Injection

Monitor Mode

Open Source

C-based

Lot's of Projects

Firmware Patching Framework

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Powered by:
1

Wi-Fi Chips in Smartphones

Nexus 5

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

2

Wi-Fi Chips in Smartphones
Apps

Nexus 5

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

3

Wi-Fi Chips in Smartphones
Apps Linux Kernel

Nexus 5

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

4

Wi-Fi Chips in Smartphones
Apps Linux Kernel
Wi-Fi Chip
Nexus 5

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

5

Wi-Fi Chips in Smartphones
Apps Linux Kernel

Wi-Fi Chip

Nexus 5

Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

6

Wi-Fi Chips in Smartphones
Apps Linux Kernel

Wi-Fi Chip

Nexus 5

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

7

Wi-Fi Chips in Smartphones
Apps Linux Kernel

Wi-Fi Chip
Nexus 5

MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

8

Wi-Fi Chips in Smartphones
Apps Linux Kernel

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

9

Wi-Fi Chips in Smartphones
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

10

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

11

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

12

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic Packs data in Ethernet frames

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

13

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic Packs data in Ethernet frames

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

14

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic Packs data in Ethernet frames

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

FullMAC firmware handles Wi-Fi connection and replaces Ethernet headers by Wi-Fi headers

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

15

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic Packs data in Ethernet frames

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

FullMAC firmware handles Wi-Fi connection and replaces Ethernet headers by Wi-Fi headers

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

16

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic Packs data in Ethernet frames

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

FullMAC firmware handles Wi-Fi connection and replaces Ethernet headers by Wi-Fi headers

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

17

Wi-Fi Chips in Smartphones

Apps
Linux Kernel Interface to Host

Generate TCP/UDP traffic Packs data in Ethernet frames

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

FullMAC firmware handles Wi-Fi connection and replaces Ethernet headers by Wi-Fi headers

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

18

Wi-Fi Firmware Handling
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

19

Wi-Fi Firmware Handling
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

Ethernet-to-Wi-Fi Bridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

20

Wi-Fi Firmware Handling
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-Fi Bridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

21

Wi-Fi Firmware Handling
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

22

Wi-Fi Firmware Handling
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

23

Wi-Fi Firmware Handling
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

24

Firmware Analysis and Patching
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

25

Firmware Analysis and Patching
Apps Linux Kernel Interface to Host

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

26

Firmware Analysis and Patching

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

27

Firmware Analysis and Patching

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Creating Firmware Patches

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

28

Firmware Analysis and Patching

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC Sublayer Management Entity
(MLME)
Low Level Hardware Control

Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Creating Firmware Patches
29

Firmware Analysis and Patching

Apps
Related Work Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5 monmob

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC Sublayer Management Entity
(MLME)
Low LevbeclmHoanrdware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Creating Firmware Patches
30

Firmware Analysis and Patching

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC Sublayer Management Entity
(MLME)
Low Level Hardware Control

Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Creating Firmware Patches
31

Static vs. Dynamic Code Analysis

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC Sublayer Management Entity
(MLME)
Low Level Hardware Control

Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
32

Static vs. Dynamic Code Analysis

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5
What about dynamic analysis?

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC Sublayer Management Entity (MLME)
Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
33

Static vs. Dynamic Code Analysis

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip
Nexus 5
What about dynamic analysis?

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
(MLME)
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
34

Static vs. Dynamic Code Analysis

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Nexus 5
What about dynamic analysis?

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
(MLME)
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
35

Static vs. Dynamic Code Analysis

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Nexus 5
What about dynamic analysis?

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
36

Static vs. Dynamic Code Analysis

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Nexus 5
What about dynamic analysis?

ROMEthernet-to-Wi-RFiABMridge

ARM Microcontroller

MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity

JTAG

De(MbuLgMCEo)re

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
37

Static vs. Dynamic Code Analysis

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Nexus 5 JTAG Debugger
What about dynamic analysis?

ROMEthernet-to-Wi-RFiABMridge

ARM Microcontroller

MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity

JTAG

De(MbuLgMCEo)re

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
38

Static vs. Dynamic Code Analysis

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Nexus 5

ROMEthernet-to-Wi-RFiABMridge

Pins not accessible

ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity

JTAG

De(MbuLgMCEo)re

JTAG Debugger

Low Level Hardware Control

What about dynamic analysis?

Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
39

Static vs. Dynamic Code Analysis

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Apps
Linux Kernel Interface to Host

Loading for Analysis

Wi-Fi Chip Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Nexus 5
What about dynamic analysis?

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Patching Firmware

Static Analysis Creating Firmware Patches
40

Static vs. Dynamic Code Analysis

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Apps
Linux Kernel Interface to Host

Wi-Fi Chip Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Nexus 5

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

41

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

42

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = UNDEF R1 = UNDEF ... PC = 0x50

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

43

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = UNDEF ... PC = 0x52

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

44

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x54

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

45

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 13 R1 = 3 ... PC = 0x56

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

46

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 13 R1 = 3 ... PC = 0x50

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

47

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 13 R1 = 3 ... PC = 0x50

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

48

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x52

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

49

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50
Halting Debug-Mode

Registers
R0 = 10 R1 = 3 ... PC = 0x52

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Control handed to external debugger

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

50

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50
Halting Debug-Mode

Registers
R0 = 10 R1 = 3 ... PC = 0x52
Monitor Debug-Mode

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Control handed to external debugger

Abort Exception  Execution continues
in exception handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

51

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50
Halting Debug-Mode

Registers
R0 = 10 R1 = 3 ... PC = 0x52
Monitor Debug-Mode

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Control handed to external debugger

Abort Exception  Execution continues
in exception handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

52

Halting vs. Monitor Debug-Mode

Apps
Linux Kernel Interface to Host

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x52

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Halting Debug-Mode

Monitor Debug-Mode

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Control handed to external debugger

Abort Exception  Execution continues
in exception handler

What happens when an abort exception occurs?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

53

Abort Exception Handling

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Example Program
0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x52
Monitor Debug-Mode

Low Level Hardware Control Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Exception  Execution continues
in exception handler

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

54

Abort Exception Handling

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x52

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

55

Operating Modes

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

56

Operating Modes

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Operating

Modes

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

57

Operating Modes

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Operating

Modes

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Regular Firmware Execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

58

Operating Modes

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C

For Handling Abort Exceptions Regular Firmware Execution

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Operating

Modes

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

59

Operating Modes

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C

For Handling Abort Exceptions Regular Firmware Execution

Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Operating

Modes

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

60

Operating Modes

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C

Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

61

Banked Registers

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

RegisterBsanked Registers

R0 = 10 R1 = 3 ... PC = 0x0C

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Stack Pointer (SP) Link Register (LR)
Saved Program Status Register
62

Banked Registers

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

RegisterBsanked Registers

R0 = 10 R1 = 3 ... PC = 0x0C

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Stack Pointer (SP) Link Register (LR)
Saved Program Status Register
63

Banked Registers

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

RegisterBsanked Registers

R0 = 10 R1 = 3 ... PC = 0x0C

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Stack Pointer (SP) Link Register (LR)
Saved Program Status Register
64

Banked Registers

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C

Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

65

Banked Registers

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Registers
R0 = 10 R1 = 3 ... PC = 0x0C SP>R13_abt LR>R14_abt

Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

66

Banked Registers

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

Software Intr.

0x08: B sw_intr_hdl

Abort (prefetch) 0x0C: B pref_abt_hdl

Abort (data)

0x10: B data_abt_hdl

...

...

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

Abort Mode System Mode

Registers
R0 = 10 R1 = 3 ... PC = 0x0C SP>R13_abt LR>R14_abt

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

We can call functions within our Abort Handler without overwriting the regluar Stack Pointer and Link Register!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

67

Banked Registers

Monitor Debug-Mode
Abort Exception  Execution continues
in exception handler
Abort Mode System Mode

Example Program

Registers

Reset Undef. Instr. Software Intr. Abort (prefetch) Abort (data) ...
pref_abt_hdl

0x00: B reset_hdl

R0 = 10

0x04: B undef_inst_hdl R1 = 3

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

0x08: B sw_intr_hdl

...

0x0C: B pref_abt_hdl

PC = 0x0C

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3

0x54: ADD R0, R0, R1

0x56: B 0x50

We can call functions

...
0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F
0..x.8C: CPS #0x1F 0x90: B handle_exceptions

within our Abort Handler without overwriting the regluar Stack Pointer and Link Register!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

68

Banked Registers

Monitor Debug-Mode
Abort Exception  Execution continues
in exception handler
Abort Mode System Mode

Example Program

Registers

Reset Undef. Instr. Software Intr. Abort (prefetch) Abort (data) ...
pref_abt_hdl

0x00: B reset_hdl

R0 = 10

0x04: B undef_inst_hdl R1 = 3

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

0x08: B sw_intr_hdl

...

0x0C: B pref_abt_hdl

PC = 0x80

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3

0x54: ADD R0, R0, R1

0x56: B 0x50

We can call functions

...
0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F
0..x.8C: CPS #0x1F 0x90: B handle_exceptions

within our Abort Handler without overwriting the regluar Stack Pointer and Link Register!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

69

Prefetch Abort Handler

Monitor Debug-Mode
Abort Exception  Execution continues
in exception handler
Abort Mode System Mode

Example Program

Registers

Reset Undef. Instr. Software Intr. Abort (prefetch) Abort (data) ...
pref_abt_hdl

0x00: B reset_hdl

R0 = 10

0x04: B undef_inst_hdl R1 = 3

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

0x08: B sw_intr_hdl

...

0x0C: B pref_abt_hdl

PC = 0x86

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

SRSDB

Instruction Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

SRSDB SP!, #0x1F
WSReS cSatonrecRaeltlufrun nStcatteio(LnRs, SPSR)

...
0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F
0..x.8C: CPS #0x1F 0x90: B handle_exceptions

withoinntooauSrtaAcbk ort Handler wDBithDeoaeucchrtetomravennestfreawrddrrietisns gbetfohree r!egluWarriteSftianaclkadPdoreinsstbearckatnodSP Link oRfemgoidsete0xr1!F (system mode)

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

70

Prefetch Abort Handler

Monitor Debug-Mode
Abort Exception  Execution continues
in exception handler
Abort Mode System Mode

Example Program

Registers

Reset Undef. Instr. Software Intr. Abort (prefetch) Abort (data) ...
pref_abt_hdl

0x00: B reset_hdl

R0 = 10

0x04: B undef_inst_hdl R1 = 3

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

0x08: B sw_intr_hdl

...

0x0C: B pref_abt_hdl

PC = 0x8C

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3

0x54: ADD R0, R0, R1

0x56: B 0x50

We can call functions

...
0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F
0..x.8C: CPS #0x1F 0x90: B handle_exceptions

within our Abort Handler without overwriting the regluar Stack Pointer and Link Register!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

71

Prefetch Abort Handler

Monitor Debug-Mode
Abort Exception  Execution continues
in exception handler
Abort Mode System Mode

Example Program

Registers

Reset Undef. Instr. Software Intr. Abort (prefetch) Abort (data) ...
pref_abt_hdl

0x00: B reset_hdl

R0 = 10

0x04: B undef_inst_hdl R1 = 3

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

0x08: B sw_intr_hdl

...

0x0C: B pref_abt_hdl

PC = 0x8C

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

CPS

Instruction Copyright©20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l1ri)ghtsreserved.

0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

CPS #0x1F
WCPeS canChcaangllefPuronccetsisoornSstate

...
0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F
0..x.8C: CPS #0x1F 0x90: B handle_exceptions

w#0ixth1Fintaorugert Ambodoer=t 0Hxa1Fndler withou(stysotevmermwodreit)ing the regluar Stack Pointer and Link Register!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

72

Prefetch Abort Handler

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = 10

Undef. Instr.

0x04: B undef_inst_hdl R1 = 3

Software Intr.

0x08: B sw_intr_hdl

...

Abort (prefetch) 0x0C: B pref_abt_hdl

PC = 0x90

Abort (data)

0x10: B data_abt_hdl

SP>R13

...

...

LR>R14

Abort Exception  Execution continues
in exception handler

0x50: MOV R0, #10 0x52: MOV R1, #3 0x54: ADD R0, R0, R1 0x56: B 0x50

...

pref_abt_hdl 0..x.80: MOV SP, LR

0x86: SRSDB SP!, #0x1F

Abort Mode System Mode

0..x.8C: CPS #0x1F 0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

73

Prefetch Abort Handler

Monitor Debug-Mode
Abort Exception  Execution continues
in exception handler
Abort Mode System Mode

Example Program

Registers

Reset Undef. Instr. Software Intr. Abort (prefetch) Abort (data) ...
pref_abt_hdl

0x00: B reset_hdl

R0 = 10

0x04: B undef_inst_hdl R1 = 3

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

0x08: B sw_intr_hdl

...

0x0C: B pref_abt_hdl

PC = 0x90

0x10: B data_abt_hdl

SP>R13

... 0x50: MOV R0, #10

LR>R14

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3
0x54: ADD R0, R0, R1 Original Wi-Fi firmware

0x56: B 0x50
... 0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F 0..x.8C: CPS #0x1F

always changes to System mode handle_exceptions handles all exceptions

0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

74

Prefetch Abort Handler

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = 10 R1 = 3 ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

pref_abt_hdl

Abort Mode System Mode

0x0C: B pref_abt_hdl

PC = 0x90

0x10: B data_abt_hdl

SP>R13

... 0x50: MOV R0, #10

LR>R14

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3
0x54: ADD R0, R0, R1 Original Wi-Fi firmware

0x56: B 0x50
... 0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F 0..x.8C: CPS #0x1F

always changes to System mode handle_exceptions handles all exceptions

0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

75

Prefetch Abort Handler

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = 10 R1 = 3 ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

pref_abt_hdl

Abort Mode System Mode

0x0C: B pref_abt_hdl

PC = 0x90

0x10: B data_abt_hdl

SP>R13

... 0x50: MOV R0, #10

LR>R14

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3
0x54: ADD R0, R0, R1 Original Wi-Fi firmware

0x56: B 0x50
... 0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F 0..x.8C: CPS #0x1F

always changes to System mode handle_exceptions handles all exceptions

0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

76

Prefetch Abort Handler

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = 10 R1 = 3 ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

pref_abt_hdl

Abort Mode System Mode

0x0C: B pref_abt_hdl

PC = 0x90

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3
0x54: ADD R0, R0, R1 Original Wi-Fi firmware

0x56: B 0x50
... 0..x.80: MOV SP, LR 0x86: SRSDB SP!, #0x1F 0..x.8C: CPS #0x1F

always changes to System mode handle_exceptions handles all exceptions

0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

77

Prefetch Abort Handler

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = 10 R1 = 3 ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

pref_abt_hdl

Abort Mode System Mode

0x0C: B pref_abt_hdl

PC = 0x90

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3
0x54: ADD R0, R0, R1 Original Wi-Fi firmware

0x56: B 0x50

always changes to System

...
0..x.80: 0x86:

MOV SP, LR SRSDB SP!,

#0x17 #0x1F

mode handle_exceptions

0..x.8C: CPS #0x1F

handles all exceptions

0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

78

Initialize Abort Stack Pointer

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ...

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Registers
R0 = 10 R1 = 3 ... PC = 0x90 SP>R13_abt LR>R14_abt

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

79

Initialize Abort Stack Pointer

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ...

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Registers
R0 = 10 R1 = 3 ... PC = 0x90 SP>R13_abt LR>R14_abt

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

80

Initialize Abort Stack Pointer

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ...

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Registers
R0 = UNDEF R1 = UNDEF ... PC = 0x00 SP>R13_svc LR>R14_svc

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

81

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = UNDEF

Undef. Instr.

0x04: B undef_inst_hdl R1 = UNDEF

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x00

0x10: B data_abt_hdl

SP>R13_svc

...

LR>R14_svc

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

82

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = UNDEF

Undef. Instr.

0x04: B undef_inst_hdl R1 = UNDEF

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x30

0x10: B data_abt_hdl

SP>R13_svc

...

LR>R14_svc

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

83

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = ...

Undef. Instr.

0x04: B undef_inst_hdl R1 = ...

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x32

0x10: B data_abt_hdl

SP>R13_svc

...

LR>R14_svc

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

84

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = ...

Undef. Instr.

0x04: B undef_inst_hdl R1 = ...

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x32

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

85

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = ...

Undef. Instr.

0x04: B undef_inst_hdl R1 = ...

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x32

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

...

0x40: Initialize processor

0x42: B c_main

Supervisor Mode Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

86

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = ...

Undef. Instr.

0x04: B undef_inst_hdl R1 = ...

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x40

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

...

0x40: Initialize processor

0x42: B c_main

Supervisor Mode Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

87

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = ...

Undef. Instr.

0x04: B undef_inst_hdl R1 = ...

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x42

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

...

0x40: Initialize processor

0x42: B c_main

Supervisor Mode Abort Mode System Mode
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

88

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = ...

Undef. Instr.

0x04: B undef_inst_hdl R1 = ...

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x42

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

...

0x40: Initialize processor

0x42: B c_main

...

Supervisor Mode

c_main 0x60: Initialize the ,,driver"

Abort Mode

0x62: Activate interrupts

System Mode

0x64: Wait for interrupts

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

89

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset

0x00: B reset_hdl

R0 = ...

Undef. Instr.

0x04: B undef_inst_hdl R1 = ...

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

...

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl

PC = 0x42

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

0x32: Change to System Mode

0x34: B setup

...

0x40: Initialize processor

0x42: B c_main c_main_hook

...

Supervisor Mode

c_main 0x60: Initialize the ,,driver"

Abort Mode

0x62: Activate interrupts

System Mode

0x64: Wait for interrupts

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

90

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = ... R1 = ... ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode

c_main

0x0C: B pref_abt_hdl

PC = 0x42

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x32: Change to System Mode

0x34: B setup

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

System Mode

0x64: Wait for interrupts

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

91

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = ... R1 = ... ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode

c_main

0x0C: B pref_abt_hdl

PC = 0x42

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x32: Change to System Mode

0x34: B setup

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

System Mode

0x64: Wait for interrupts

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

92

Initialize Abort Stack Pointer

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = ... R1 = ... ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode

c_main

0x0C: B pref_abt_hdl

PC = 0x42

0x10: B data_abt_hdl

SP>R13

...

LR>R14

0x30: Check exception vectors

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x32: Change to System Mode

0x34: B setup

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

System Mode

0x64: Wait for interrupts

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

93

Initialize Abort Stack Pointer
Monitor Debug-Mode

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

c_main

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts 0x64: Wait for interrupts

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main
94

Initialize Abort Stack Pointer

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

c_main

uint32 stack_abt[256] = { 0x54424153 };
void __attribute__((optimize("O0"))) set_abort_SP(void) {
register uint32 sp_abt asm("r0") = (uint32) &stack_abt[255];
dbg_change_processor_mode(DBG_PROCESSOR_MODE_ABT); asm("mov sp, %[value]" : : [value] "r" (sp_abt)); dbg_change_processor_mode(DBG_PROCESSOR_MODE_SYS); }

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts 0x64: Wait for interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

95

Initialize Abort Stack Pointer

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

c_main

uint32 stack_abt[256] = { 0x54424153 };
void __attribute__((optimize("O0"))) set_abort_SP(void) {
register uint32 sp_abt asm("r0") = (uint32) &stack_abt[255];
dbg_change_proceCshsaonrg_emotdoeA(DbBoGr_tPMROoCdEeSSOR_MODE_ABT);
asm("mov sp, %[value]" : : [value] "r" (sp_abt)); dbg_change_processor_mode(DBG_PROCESSOR_MODE_SYS); }

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts 0x64: Wait for interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

96

Initialize Abort Stack Pointer

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

c_main

uint32 stack_abt[256] = { 0x54424153 };
void __attribute__((optimize("O0"))) set_abort_SP(void) {
register uint32 sp_abt asm("r0") = (uint32) &stack_abt[255];
dbg_change_proceCshsaonrg_emotdoeA(DbBoGr_tPMROoCdEeSSOR_MODE_ABT); asm("moSvetsSpt,ac%k[vPaoliunete]r" to: e:nd[voaflsutea]ck"_ra"bt(saprr_aaybt));
dbg_change_processor_mode(DBG_PROCESSOR_MODE_SYS); }

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts 0x64: Wait for interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

97

Initialize Abort Stack Pointer

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

c_main

uint32 stack_abt[256] = { 0x54424153 };
void __attribute__((optimize("O0"))) set_abort_SP(void) {
register uint32 sp_abt asm("r0") = (uint32) &stack_abt[255];
dbg_change_proceCshsaonrg_emotdoeA(DbBoGr_tPMROoCdEeSSOR_MODE_ABT); asm("moSvetsSpt,ac%k[vPaoliunete]r" to: e:nd[voaflsutea]ck"_ra"bt(saprr_aaybt)); dbg_change_procCehssaonrg_emtoodeS(yDsBteGm_PRMOCoEdSeSOR_MODE_SYS);
}

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts 0x64: Wait for interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

98

Initialize Abort Stack Pointer

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

c_main

uint32 stack_abt[256] = { 0x54424153 };
void __attribute__((optimize("O0"))) set_abort_SP(void) {
register uint32 sp_abt asm("r0") = (uint32) &stack_abt[255];
dbg_change_proceCshsaonrg_emotdoeA(DbBoGr_tPMROoCdEeSSOR_MODE_ABT); asm("moSvetsSpt,ac%k[vPaoliunete]r" to: e:nd[voaflsutea]ck"_ra"bt(saprr_aaybt)); dbg_change_procCehssaonrg_emtoodeS(yDsBteGm_PRMOCoEdSeSOR_MODE_SYS);
}

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts 0x64: Wait for interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

99

Initialize Abort Stack Pointer

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

c_main

uint32 stack_abt[256] = { 0x54424153 };
void __attribute__((optimize("O0"))) set_abort_SP(void) {
register uint32 sp_abt asm("r0") = (uint32) &stack_abt[255];
dbg_change_proceCshsaonrg_emotdoeA(DbBoGr_tPMROoCdEeSSOR_MODE_ABT); asm("moSvetsSpt,ac%k[vPaoliunete]r" to: e:nd[voaflsutea]ck"_ra"bt(saprr_aaybt)); dbg_change_procCehssaonrg_emtoodeS(yDsBteGm_PRMOCoEdSeSOR_MODE_SYS);
}

... 0x40: Initialize processor 0x42: B c_main c_main_hook
... 0x60: Initialize the ,,driver" 0x62: Activate interrupts 0x64: Wait for interrupts

c_main_hook: 0x60: PUSH {R0-R3,LR} 0x62: BL set_abort_SP 0x64: POP {R0-R3,LR} 0x66: B c_main

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

100

Initialize Abort Stack Pointer
Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function · EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

101

Analyzing Handle Exceptions Function

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = 10 R1 = 3 ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

pref_abt_hdl

0x0C: B pref_abt_hdl

PC = 0x90

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3
0x54: ADD R0, R0, R1 Original Wi-Fi firmware

0x56: B 0x50

always changes to System

...
0..x.80: 0x86:

MOV SP, LR SRSDB SP!,

#0x17 #0x1F

mode handle_exceptions

0..x.8C: CPS #0x1F

handles all exceptions

0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

102

Analyzing Handle Exceptions Function

Monitor

Example Program

Registers

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = 10 R1 = 3 ...

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

pref_abt_hdl

0x0C: B pref_abt_hdl

PC = 0x90

0x10: B data_abt_hdl

SP>R13_abt

... 0x50: MOV R0, #10

LR>R14_abt

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

0x52: MOV R1, #3
0x54: ADD R0, R0, R1 Original Wi-Fi firmware

0x56: B 0x50

always changes to System

...
0..x.80: 0x86:

MOV SP, LR SRSDB SP!,

#0x17 #0x1F

mode handle_exceptions

0..x.8C: CPS #0x1F

handles all exceptions

0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

103

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ...

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

104

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ...

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

Supervisor Mode Abort Mode System Mode

pref_abt_hdl

...
0..x.80: MOV SP, LR #0x17 0x86: SRSDB SP!, #0x1F
0..x.8C: CPS #0x1F 0x90: B handle_exceptions

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

105

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

106

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

107

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4 LR (new) := Breakpoint`s PC Address

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

108

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4 LR (new) := Breakpoint`s PC Address

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

109

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4
LR (new) :=SBRreSaDkpBoiInnt`sstPrCuAcdtdiorenss
SRSDB SP!, #0x17 SRS Store Return State (LR, SPSR)

0x88: SUB SP, SP, #24

onto a Stack

0x8A: PUSH {R0-R7}

DB Decrement address before

0x8C: MOV R0, #3

each transfer

Supervisor Mode

0x8E: B handle_exceptions ! Write final address back to SP

Abort Mode

of mode 0x17 (abort mode)

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

110

Our Prefetch Abort Handler

Monitor

Example Program

Abort Stack

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4
LR (new) :=SBRreSaDkpBoiInnt`sstPrCuAcdtdiorenss
SRSDB SP!, #0x17 SRS Store Return State (LR, SPSR)

0x88: SUB SP, SP, #24

onto a Stack

0x8A: PUSH {R0-R7}

DB Decrement address before

0x8C: MOV R0, #3

each transfer

Supervisor Mode

0x8E: B handle_exceptions ! Write final address back to SP

Abort Mode

of mode 0x17 (abort mode)

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

111

Our Prefetch Abort Handler

Monitor

Example Program

Abort Stack

Debug-Mode Reset

0x00: B reset_hdl

SPSR = CPSR_SYS LR = PC_SYS

Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4
LR (new) :=SBRreSaDkpBoiInnt`sstPrCuAcdtdiorenss
SRSDB SP!, #0x17 SRS Store Return State (LR, SPSR)

0x88: SUB SP, SP, #24

onto a Stack

0x8A: PUSH {R0-R7}

DB Decrement address before

0x8C: MOV R0, #3

each transfer

Supervisor Mode

0x8E: B handle_exceptions ! Write final address back to SP

Abort Mode

of mode 0x17 (abort mode)

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

112

Our Prefetch Abort Handler

Monitor

Example Program

Abort Stack

Debug-Mode Reset

0x00: B reset_hdl

SPSR = CPSR_SYS LR = PC_SYS

Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4 LR (new) := Breakpoint`s PC Address

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

113

Our Prefetch Abort Handler

Monitor

Example Program

Abort Stack

Debug-Mode Reset

0x00: B reset_hdl

SPSR = CPSR_SYS LR = PC_SYS R0

Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4 LR (new) := Breakpoint`s PC Address

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

114

Our Prefetch Abort Handler

Monitor

Example Program

Abort Stack

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

SPSR = CPSR_SYS LR = PC_SYS R0 LR_ABT

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4 LR (new) := Breakpoint`s PC Address

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

115

Our Prefetch Abort Handler

Monitor

Example Program

Abort Stack

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

SPSR = CPSR_SYS LR = PC_SYS R0 LR_ABT

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

LR = Breakpoint`s PC Address + 4 LR (new) := Breakpoint`s PC Address

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

116

Our Prefetch Abort Handler

Monitor

Example Program

Debug-Mode Reset

0x00: B reset_hdl

Undef. Instr.

0x04: B undef_inst_hdl

ToDos to Create DISYofDtewbarueggIentrr. 0x08: B sw_intr_hdl

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7}

0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS R0 LR_ABT R7 R6 R5 R4 R3 R2 R1 R0
117

Our Prefetch Abort Handler

Monitor

Example Program

Abort Stack

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

SPSR = CPSR_SYS LR = PC_SYS R0 LR_ABT

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

R7 R6 R5 R4 R3 R2 R1 R0

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7} R0 := Exception ID (3  Prefetch Abort) 0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

118

Our Prefetch Abort Handler

Monitor

Example Program

Registers

Abort Stack

Debug-Mode Reset
Undef. Instr.
ToDos to Create DISYofDtewbarueggIentrr.

0x00: B reset_hdl 0x04: B undef_inst_hdl 0x08: B sw_intr_hdl

R0 = 3

SPSR = CPSR_SYS LR = PC_SYS R0 LR_ABT

· ·

Stay Save
·

iIRnneiAtgibiasoltiezrter MSAtBoaTdteeSttaocAA.Akb.bbPo.ooorrritttnMte((ropddareteSafte)atcck h)

· AbnoarlytzEexhceapntdiolne_exceptions function

· EImxepcluetmioennctoanbtirneuaekspoint handler

·in Aexcctievpatieonbrheaankdploeirnts

0x0C: B pref_abt_hdl 0x10: B data_abt_hdl ... 0x80: SUB LR, LR, #4 0x82: SRSDB SP!, #0x17 0x84: PUSH {R0} 0x86: PUSH {LR}

R7 R6 R5 R4 R3 R2 R1 R0

0x88: SUB SP, SP, #24

0x8A: PUSH {R0-R7} R0 := Exception ID (3  Prefetch Abort) 0x8C: MOV R0, #3

Supervisor Mode

0x8E: B handle_exceptions

Abort Mode

System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

119

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger

0xA4: LDMIA R4!, {R1,R3} 0xA6: MRS R2, CPSR

· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer 
· AbnoarlytzEexhceapntdiolne_exceptions function

0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

· EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11

0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS R0 LR_ABT R7 R6 R5 R4 R3 R2 R1 R0
120

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger

0xA4: LDMIA R4!, {R1,R3} 0xA6: MRS R2, CPSR

· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer 
· AbnoarlytzEexhceapntdiolne_exceptions function

0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

· EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11

0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS R0 LR_ABT R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
121

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger

0xA4: LDMIA R4!, {R1,R3} 0xA6: MRS R2, CPSR

· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer 
· AbnoarlytzEexhceapntdiolne_exceptions function

0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

· EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11

0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
122

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger

0xA4: LDMIA R4!, {R1,R3} 0xA6: MRS R2, CPSR

· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer 
· AbnoarlytzEexhceapntdiolne_exceptions function

0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

· EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11

0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
123

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function

0xA4: LDMIA R4!, {R1,R3}

0xA6: MRS R2, CPSR 0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12

Processor state when breakpoint was triggered

0xAC: STR R1, [R4]

0xAE: AND R1, R3, #64

0xB0: MOV R7, SP

· EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11

0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
124

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function

0xA4: LDMIA R4!, {R1,R3}

0xA6: MRS R2, CPSR 0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12

Processor state when breakpoint was triggered

0xAC: STR R1, [R4]

0xAE: AND R1, R3, #64

0xB0: MOV R7, SP

· EImxepcluetmioennctoanbtirneuaekspoint handler ·in Aexcctievpatieonbrheaankdploeirnts

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11

0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
125

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function

0xA4: LDMIA R4!, {R1,R3}

0xA6: MRS R2, CPSR 0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12

Processor state when breakpoint was triggered

0xAC: STR R1, [R4]

0xAE: AND R1, R3, #64

0xB0: MOV R7, SP

 Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11 0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
126

Analyzing handle_exceptions

Monitor

handle_exceptions

Registers

Debug-Mode

0xA0: MOV R4, SP 0xA2: ADD R4, R4, #64

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function

0xA4: LDMIA R4!, {R1,R3}

0xA6: MRS R2, CPSR 0xA8: PUSH {R0-R3} 0xAA: SUB R4, R4, #12

Processor state when breakpoint was triggered

0xAC: STR R1, [R4]

0xAE: AND R1, R3, #64

0xB0: MOV R7, SP

 Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xB2: ADD R7, R7, #88 0xB4: MOV R6, R12 0xB6: MOV R5, R11 0xB8: MOV R4, R10

0xBA: MOV R3, R9

0xBC: MOV R2, R8

Supervisor Mode Abort Mode

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

System Mode

0xC4: BL choose_exception_handler 0xC6: CPSID IF

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM De0bxuCg8g:erAfDoDr WSiP-F,i CShPi,ps#48

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
127

0xA6: MRS R2, CPSR

0xA8: PUSH {R0-R3}

0xAA: SUB R4, R4, #12

Analyzing handle_exceptions 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

Monitor Debug-Mode

0xB2: ADD R7, R7, #88
ha0nxdB4le: _MeOVxcRe6,ptRi1o2ns 0xB6: MOV R5, R11 0xB8: MOV R4, R10 0xBA: MOV R3, R9

Registers
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer 

0xBC: MOV R2, R8

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

Processor state when breakpoint was triggered

0xC4: BL choose_exception_handler

0xC6: CPSID IF

· AbnoarlytzEexhceapntdiolne_exceptions function

0xC8: ADD SP, SP, #48

 Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xCA: POP {R0-R6} 0xCC: MOV R8, R0 0xCE: MOV R9, R1 0xD0: MOV R10, R2

Abort Stack
PCR_0SYS LR_ABT SP_ABT
R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID

0xD2: MOV R11, R3

Restores saved registers

0xD4: MOV R12, R4

Supervisor Mode

0xD6: MOV LR, R6 0xD8: SUB SP, SP, #60

Abort Mode

0xDA: POP {R0-R7}

System Mode

0xDC: ADD SP, SP, #32 0xDE: RFEFD SP!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

128

0xA6: MRS R2, CPSR

0xA8: PUSH {R0-R3}

0xAA: SUB R4, R4, #12

Analyzing handle_exceptions 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

0xB2: ADD R7, R7, #88

Monitor

ha0nxdB4le: _MeOVxcRe6,ptRi1o2ns

Registers

Abort Stack

Debug-Mode

0xB6: MOV R5, R11 0xB8: MOV R4, R10

R0 = 3

PCR_0SYS

0xBA: MOV R3, R9

LR_ABT SP_ABT

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function  Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS

0xBC: MOV R2, R8 0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

R12

Processor stRatFeEwFhDenInstructiRRRRo119801n

breakpoint was triggerReFdEFD SP!

R7 R6 R5

0xC4: 0xC6: 0xC8: 0xCA:

BCLPScIhDooIsFe_exception_handlerRFE

ADD SP, SP, #48

POP {R0-R6}

FD

R4

Return From ExceptionRR:32writes

PC and CPSR back

R1 R0 CPSR_SYS

Fulldescending stackCPPSCR__SAYSBT

Exception ID

·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xCC: MOV R8, R0 0xCE: MOV R9, R1 0xD0: MOV R10, R2

SP Points at PC and CPSR SP! Write final address back to SP

0xD2: MOV R11, R3

Restores saved registers

0xD4: MOV R12, R4

Supervisor Mode

0xD6: MOV LR, R6 0xD8: SUB SP, SP, #60

Abort Mode

0xDA: POP {R0-R7}

System Mode

0xDC: ADD SP, SP, #32 0xDE: RFEFD SP!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

129

0xA6: MRS R2, CPSR

0xA8: PUSH {R0-R3}

0xAA: SUB R4, R4, #12

Analyzing handle_exceptions 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

0xB2: ADD R7, R7, #88

Monitor

ha0nxdB4le: _MeOVxcRe6,ptRi1o2ns

Registers

Abort Stack

Debug-Mode

0xB6: MOV R5, R11 0xB8: MOV R4, R10

R0 = 3

SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS

0xBA: MOV R3, R9

LR_ABT SP_ABT

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function  Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS

0xBC: MOV R2, R8 0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

R12

Processor stRatFeEwFhDenInstructiRRRRo119801n

breakpoint was triggerReFdEFD SP!

R7 R6 R5

0xC4: 0xC6: 0xC8: 0xCA:

BCLPScIhDooIsFe_exception_handlerRFE

ADD SP, SP, #48

POP {R0-R6}

FD

R4

Return From ExceptionRR:32writes

PC and CPSR back

R1 R0 CPSR_SYS

Fulldescending stackCPPSCR__SAYSBT

Exception ID

·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xCC: MOV R8, R0 0xCE: MOV R9, R1 0xD0: MOV R10, R2

SP Points at PC and CPSR SP! Write final address back to SP

0xD2: MOV R11, R3

Restores saved registers

0xD4: MOV R12, R4

Supervisor Mode

0xD6: MOV LR, R6 0xD8: SUB SP, SP, #60

Abort Mode

0xDA: POP {R0-R7}

System Mode

0xDC: ADD SP, SP, #32 0xDE: RFEFD SP!

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

130

0xA6: MRS R2, CPSR

0xA8: PUSH {R0-R3}

0xAA: SUB R4, R4, #12

Analyzing handle_exceptions 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

0xB2: ADD R7, R7, #88

Monitor

ha0nxdB4le: _MeOVxcRe6,ptRi1o2ns

Registers

Abort Stack

Debug-Mode

0xB6: MOV R5, R11 0xB8: MOV R4, R10

R0 = 3

SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS

0xBA: MOV R3, R9

LR_ABT SP_ABT

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function  Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS

0xBC: MOV R2, R8 0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

R12

Processor stRatFeEwFhDenInstructiRRRRo119801n

breakpoint was triggerReFdEFD SP!

R7 R6 R5

0xC4: 0xC6: 0xC8: 0xCA:

BCLPScIhDooIsFe_exception_handlerRFE

ADD SP, SP, #48

POP {R0-R6}

FD

R4

Return From ExceptionRR:32writes

PC and CPSR back

R1 R0 CPSR_SYS

Fulldescending stackCPPSCR__SAYSBT

Exception ID

·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xCC: MOV R8, R0 0xCE: MOV R9, R1 0xD0: MOV R10, R2

SP Points at PC and CPSR SP! Write final address back to SP

0xD2: MOV R11, R3

Restores saved registers

Supervisor Mode Abort Mode System Mode

0xD4: MOV R12, R4 0xD6: MOV LR, R6 0xD8: SUB SP, SP, #60 0xDA: POP {R0-R7} 0xDC: ADD SP, SP, #32 0xDE: RFEFD SP!

After handling an exception we can return to regular program execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

131

0xA6: MRS R2, CPSR

0xA8: PUSH {R0-R3}

0xAA: SUB R4, R4, #12

Analyzing handle_exceptions 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

0xB2: ADD R7, R7, #88

Monitor

ha0nxdB4le: _MeOVxcRe6,ptRi1o2ns

Registers

Abort Stack

Debug-Mode

0xB6: MOV R5, R11 0xB8: MOV R4, R10

R0 = 3

SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS

0xBA: MOV R3, R9

LR_ABT SP_ABT

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS

0xBC: MOV R2, R8 0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

R12

Processor stRatFeEwFhDenInstructiRRRRo119801n

breakpoint was triggerReFdEFD SP!

R7 R6 R5

0xC4: 0xC6: 0xC8: 0xCA:

BCLPScIhDooIsFe_exception_handlerRFE

ADD SP, SP, #48

POP {R0-R6}

FD

R4

Return From ExceptionRR:32writes

PC and CPSR back

R1 R0 CPSR_SYS

Fulldescending stackCPPSCR__SAYSBT

Exception ID

·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xCC: MOV R8, R0 0xCE: MOV R9, R1 0xD0: MOV R10, R2

SP Points at PC and CPSR SP! Write final address back to SP

0xD2: MOV R11, R3

Restores saved registers

Supervisor Mode Abort Mode System Mode

0xD4: MOV R12, R4 0xD6: MOV LR, R6 0xD8: SUB SP, SP, #60 0xDA: POP {R0-R7} 0xDC: ADD SP, SP, #32 0xDE: RFEFD SP!

After handling an exception we can return to regular program execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

132

0xA6: MRS R2, CPSR

0xA8: PUSH {R0-R3}

0xAA: SUB R4, R4, #12

Analyzing handle_exceptions 0xAC: STR R1, [R4] 0xAE: AND R1, R3, #64 0xB0: MOV R7, SP

Monitor Debug-Mode

0xB2: ADD R7, R7, #88
ha0nxdB4le: _MeOVxcRe6,ptRi1o2ns 0xB6: MOV R5, R11 0xB8: MOV R4, R10 0xBA: MOV R3, R9

Registers
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function 

0xBC: MOV R2, R8

0xBE: ADD SP, SP, #72 0xC0: PUSH {R2-R7} 0xC2: SUB SP, SP, #48

Processor state when breakpoint was triggered

0xC4: BL choose_exception_handler

0xC6: CPSID IF

0xC8: ADD SP, SP, #48

 Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0xCA: POP {R0-R6} 0xCC: MOV R8, R0 0xCE: MOV R9, R1 0xD0: MOV R10, R2

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID

0xD2: MOV R11, R3

Restores saved registers

Supervisor Mode Abort Mode System Mode

0xD4: MOV R12, R4 0xD6: MOV LR, R6 0xD8: SUB SP, SP, #60 0xDA: POP {R0-R7} 0xDC: ADD SP, SP, #32 0xDE: RFEFD SP!

After handling an exception we can return to regular program execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

133

Analyzing handle_exceptions

Monitor Debug-Mode

choose_exception _handlerRegisters
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

134

Calling Prefetch Abort Handler

Monitor Debug-Mode

choose_exception _handler Registers
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

135

Calling Prefetch Abort Handler

Monitor Debug-Mode

choose_exception _handler Registers
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE

Check whether Exception ID (R0) equals 6 (fast interrupt/FIQ)

0x0FC: CPSIE F

0x0FE: MOV R0, SP

0x100: PUSH {LR}

0x102: POP {LR}

0x104: B handle_FIQ_or_trigger_trap

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

136

Calling Prefetch Abort Handler

Monitor Debug-Mode

choose_exception _handler Registers
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE

Check whether Exception ID (R0) equals 6 (fast interrupt/FIQ)

0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR}

Handles FIQ or prints debug information and stops execution

0x104: B handle_FIQ_or_trigger_trap

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

137

Calling Prefetch Abort Handler

Monitor Debug-Mode

choose_exception _handler Registers
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE

Check whether Exception ID (R0) equals 6 (fast interrupt/FIQ)

0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR}

Handles FIQ or prints debug information and stops execution

0x104: B handle_FIQ_or_trigger_trap

Supervisor Mode Abort Mode System Mode

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

138

Calling Prefetch Abort Handler

Monitor Debug-Mode

choose_exception _handler Registers
R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

Supervisor Mode Abort Mode System Mode

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

139

Calling Prefetch Abort Handler

Monitor

choose_exception _handler Registers

Debug-Mode

0x0F0: CMP R0, #3

R0 = 3

0x0F2: BEQ pref_abort

ToDos to Create DIY Debugger

0x0F4: CMP R0, #6

· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler
· Activate breakpoints

0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

Supervisor Mode Abort Mode System Mode

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

140

Calling Prefetch Abort Handler

Monitor

choose_exception _handler Registers

Debug-Mode

0x0F0: CMP R0, #3

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F2: BEQ pref_abort 0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

pref_abort:

Supervisor Mode Abort Mode System Mode

0x106: MOV R0, SP 0x108: PUSH {LR} 0x10A: POP {LR} 0x10C: B handle_pref_abort_exception

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

141

Calling Prefetch Abort Handler

Monitor

choose_exception _handler Registers

Debug-Mode

0x0F0: CMP R0, #3

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F2: BEQ pref_abort 0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

pref_abort:

Supervisor Mode Abort Mode System Mode

0x106: MOV R0, SP 0x108: PUSH {LR} 0x10A: POP {LR} 0x10C: B handle_pref_abort_exception

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

142

Calling Prefetch Abort Handler

Monitor

choose_exception _handler Registers

Debug-Mode

0x0F0: CMP R0, #3

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F2: BEQ pref_abort 0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

pref_abort:

Supervisor Mode Abort Mode System Mode

0x106: MOV R0, SP 0x108: PUSH {LR} 0x10A: POP {LR} 0x10C: B handle_pref_abort_exception

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

143

Calling Prefetch Abort Handler

Monitor

choose_exception _handler Registers

Debug-Mode

0x0F0: CMP R0, #3

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F2: BEQ pref_abort 0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

pref_abort:

Supervisor Mode Abort Mode System Mode

0x106: MOV R0, SP 0x108: PUSH {LR} 0x10A: POP {LR} 0x10C: B handle_pref_abort_exception

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

144

Calling Prefetch Abort Handler

Monitor

choose_exception _handler Registers

Debug-Mode

0x0F0: CMP R0, #3

R0 = 3

ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F2: BEQ pref_abort 0x0F4: CMP R0, #6 0x0F6: BNE 0xFE 0x0F8: CMP R1, #64 0x0FA: BEQ 0xFE 0x0FC: CPSIE F 0x0FE: MOV R0, SP 0x100: PUSH {LR} 0x102: POP {LR} 0x104: B handle_FIQ_or_trigger_trap

pref_abort:

Supervisor Mode Abort Mode System Mode

0x106: MOV R0, SP 0x108: PUSH {LR} 0x10A: POP {LR} 0x10C: B handle_pref_abort_exception

Abort Stack
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

145

Calling Prefetch Abort Handler

Monitor

choose_exception _handler Registers Abort Stack

Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

0x0F0: CMP R0, #3

R0 = 3

0x0F2: BEQ pref_abort

0x0F4: CMP R0, #6

0x0F6: BNE 0xFE

0x0F8: CMP R1, #64

0x0FA: BEQ 0xFE

0x0FC: CPSIE F

0x0FE: MOV R0, SP

0x100: PUSH {LR}

0x102: POP {LR}

0x104: B handle_FIQ_or_trigger_trap

SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID
 We want to handle our

Supervisor Mode Abort Mode System Mode

pref_abort: 0x106: MOV R0, SP 0x108: PUSH {LR} First argument points to trace 0x10A: POP {LR} 0x10C: B handle_pref_abort_exception

breakpoint instead of triggering the trap

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

146

Fixing LR and SP in Trace

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints
Supervisor Mode Abort Mode System Mode

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace); ... }
void fix_sp_lr(struct trace *trace) {
register unsigned int sp_sys asm("r1"); register unsigned int lr_sys asm("r2");
dbg_disable_monitor_mode_debugging();

Trace
SPSR = CPSR_SYS LR = PC_SYS PCR_0SYS LR_ABT SP_ABT R12 R11 R10 R9 R8 R7 R6 R5 R4 R3 R2 R1 R0 CPSR_SYS CPSR_ABT PC_SYS Exception ID

dbg_change_processor_mode(DBG_PROCESSOR_MODE_SYS);

asm("mov %[result], sp" : [result] "=r" (sp_sys));

asm("mov %[result], lr" : [result] "=r" (lr_sys));

dbg_change_processor_mode(DBG_PROCESSOR_MODE_ABT);

dbg_enable_monitor_mode_debugging();

trace->lr = lr_sys; trace->sp = sp_sys; }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

147

Fixing LR and SP in Trace

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints
Supervisor Mode Abort Mode System Mode

void handle_pref_abort_exception(struct trace *trace) {

Trace

fix_sp_lr(trace);

SPSR = CPSR_SYS LR = PC_SYS

...

PCR_0SYS LR_ABT

}

SP_ABT R12

R11

R10

void

R9 R8 R7

fix_sp_lr(struct trace *trace)

R6 R5

{

R4 R3

register unsigned int sp_sys asm("r1");

R2 R1

register unsigned int lr_sys asm("r2");

R0 CPSR_SYS

CPSR_ABT

PC_SYS

ddbbgg__dcihDsaanisbgalebe_l_pemrdoonceiebtsuosgrog_rem_romadoedn_edd(eeDnbBuGteg_rgPiRSnOygCsE(teS)mS;ORM_MoOdDeE_SYS); Exception ID

asm("mov %[result], sp" : [result] "=r" (sp_sys));

asm("mov %[result], lr" : [result] "=r" (lr_sys));

dbg_change_processor_mode(DBG_PROCESSOR_MODE_ABT);

dbg_enable_monitor_mode_debugging();

trace->lr = lr_sys; trace->sp = sp_sys; }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

148

Fixing LR and SP in Trace

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints
Supervisor Mode Abort Mode System Mode

void handle_pref_abort_exception(struct trace *trace) {

Trace

fix_sp_lr(trace);

SPSR = CPSR_SYS LR = PC_SYS

...

PCR_0SYS LR_ABT

}

SP_ABT R12

R11

R10

void

R9 R8 R7

fix_sp_lr(struct trace *trace)

R6 R5

{

R4 R3

register unsigned int sp_sys asm("r1");

R2 R1

register unsigned int lr_sys asm("r2");

R0 CPSR_SYS

CPSR_ABT

PC_SYS

ddbbgg__dcihDsaanisbgalebe_l_pemrdoonceiebtsuosgrog_rem_romadoedn_edd(eeDnbBuGteg_rgPiRSnOygCsE(teS)mS;ORM_MoOdDeE_SYS); Exception ID

aassmm((""mmoovvSt%%o[[rrreeeSssPuu_llttS]]Y,,S aslnprd"" L::R_[[SrrYeeSssuuinllttR]]1""a==nrrd"" R((2slpr__ssyyss))));;

dbg_change_processor_mode(DBG_PROCESSOR_MODE_ABT);

dbg_enable_monitor_mode_debugging();

trace->lr = lr_sys; trace->sp = sp_sys; }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

149

Fixing LR and SP in Trace

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints
Supervisor Mode Abort Mode System Mode

void handle_pref_abort_exception(struct trace *trace) {

Trace

fix_sp_lr(trace);

SPSR = CPSR_SYS LR = PC_SYS

...

PCR_0SYS LR_ABT

}

SP_ABT R12

R11

R10

void

R9 R8 R7

fix_sp_lr(struct trace *trace)

R6 R5

{

R4 R3

register unsigned int sp_sys asm("r1");

R2 R1

register unsigned int lr_sys asm("r2");

R0 CPSR_SYS

CPSR_ABT

PC_SYS

ddbbgg__dcihDsaanisbgalebe_l_pemrdoonceiebtsuosgrog_rem_romadoedn_edd(eeDnbBuGteg_rgPiRSnOygCsE(teS)mS;ORM_MoOdDeE_SYS); Exception ID

aassmm((""mmoovvSt%%o[[rrreeeSssPuu_llttS]]Y,,S aslnprd"" L::R_[[SrrYeeSssuuinllttR]]1""a==nrrd"" R((2slpr__ssyyss))));;

ddbbgg__Rceehntaaunbrglnee__topmroAonbcietosorsrt o_Mrm_oomddoeed_edae(nbDduBgGreg_-iPenRngOaC(bE)S;leSOdRe_bMuOgDgEe_rABT);

trace->lr = lr_sys; trace->sp = sp_sys; }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

150

Fixing LR and SP in Trace

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS  ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints
Supervisor Mode Abort Mode System Mode

void handle_pref_abort_exception(struct trace *trace) {

Trace

fix_sp_lr(trace);

SPSR = CPSR_SYS LR = PC_SYS

... }

PCR_0SYS SLLSRPRP____AASSYYBBSSTT
R12

R11

R10

void

R9 R8 R7

fix_sp_lr(struct trace *trace)

R6 R5

{

R4 R3

register unsigned int sp_sys asm("r1");

R2 R1

register unsigned int lr_sys asm("r2");

R0 CPSR_SYS

CPSR_ABT

PC_SYS

ddbbgg__dcihDsaanisbgalebe_l_pemrdoonceiebtsuosgrog_rem_romadoedn_edd(eeDnbBuGteg_rgPiRSnOygCsE(teS)mS;ORM_MoOdDeE_SYS); Exception ID

aassmm((""mmoovvSt%%o[[rrreeeSssPuu_llttS]]Y,,S aslnprd"" L::R_[[SrrYeeSssuuinllttR]]1""a==nrrd"" R((2slpr__ssyyss))));;

ddbbgg__Rceehntaaunbrglnee__topmroAonbcietosorsrt o_Mrm_oomddoeed_edae(nbDduBgGreg_-iPenRngOaC(bE)S;leSOdRe_bMuOgDgEe_rABT);

trace->lr trace->sp

= =

lsrp__ssyyss;;Update Trace

}

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

151

Handling Breakpoints

Monitor Debug-Mode
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · AbnoarlytzEexhceapntdiolne_exceptions function   Exe·cuFtioxnLRc/oSnPt_inAuBeTs LR/SP_SYS  ·in Iemxcpelepmtioennthanbdrelearkpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace); ... }

Supervisor Mode Abort Mode System Mode

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

152

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints if(dbg_is_breakpoint_enabled(0)) {
if (dbg_triggers_on_breakpoint_address (0, trace->pc)) {
// Handle Breakpoint: // - Print information // - Change register values in trace
dbg_disable_breakpoint(0); } }

Supervisor Mode Abort Mode System Mode

... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
153

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints if(dbg_is_breakpoint_enabled(0)) {
if (dbg_triggers_on_breakpoint_address (0, trace->pc)) {
// Handle Breakpoint: // - Print information // - Change register values in trace
dbg_disable_breakpoint(0); } }

Supervisor Mode Abort Mode System Mode

... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
154

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled
if (dbg_triggers_on_breakpoint_address (0, trace->pc)) {
// Handle Breakpoint: // - Print information // - Change register values in trace
dbg_disable_breakpoint(0); } }

Supervisor Mode Abort Mode System Mode

... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
155

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint: // - Print information // - Change register values in trace
dbg_disable_breakpoint(0); } }

Supervisor Mode Abort Mode System Mode

... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
156

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_disable_breakpoint(0); } }

Supervisor Mode Abort Mode System Mode

... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
157

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Supervisor Mode Abort Mode System Mode

... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
158

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Supervisor Mode Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
159

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Supervisor Mode Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
160

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler  · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Supervisor Mode Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
161

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
162

Handling Breakpoints

Simplest Implementation Breakpoint triggers only once
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
163

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
164

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
165

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
166

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
167

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
168

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
169

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
170

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
171

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
172

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
173

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
174

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode
// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace
dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
} }

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

start: MOV R0, #1 MOV R0, #3 B start
175

Handling Breakpoints

Simplest Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void handle_pref_abort_exception(struct trace *trace) {
fix_sp_lr(trace);
// Do for any of the four hardware breakpoints
if(dbgC_ihse_cbkrweahkeptohienrtb_reenaakbpleodin(t0)is) e{nabled Chiefck(wdbhge_tthreirggberersa_kopno_ibnrteaadkdproeisnste_qadudarlsestshe progra(m0,ctoruanctee-r>opfct)h)e{system mode

start: MOV R0, #1 MOV R0, #3 B start

// Handle Breakpoint:
W/ri/te c-odPreitnothiannfdolremtahteiobnreakpoint
// - Change register values in trace

dbg_dDiissaabblle_tbhreeabkrepoaiknpto(i0n)t;
}
}

... }

Continue firmware execution

We are in an endless debugging loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

176

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints

if (dbg_is_breakpoint_enabled(0)) {

if (dbg_triggers_on_breakpoint_address (0, trace->pc)) {

// Handle Breakpoint:

breakpoint_hit |= DBGBP0;

dbg_set_breakpoint_type_to_instr_addr_mismatch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

177

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (dbg_triggers_on_breakpoint_address (0, trace->pc)) {

// Handle Breakpoint:

breakpoint_hit |= DBGBP0;

dbg_set_breakpoint_type_to_instr_addr_mismatch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

178

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// Handle Breakpoint:

breakpoint_hit |= DBGBP0;

dbg_set_breakpoint_type_to_instr_addr_mismatch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

179

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpoint_hit |= DBGBP0;

dbg_set_breakpoint_type_to_instr_addr_mismatch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

180

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbg_set_breakpoint_type_to_instr_addr_mismatch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

181

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

182

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

183

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

184

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

185

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

186

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} else if (breakpoint_hit & DBGBP0) {

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

187

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

dbg_set_breakpoint_type_to_instr_addr_match(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

188

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

dbg_Sseettb_rberaekapkopionitntto_ttyripgeg_etroo_ninasdtdr_reasdsdrm_amtacthch(0);

breakpoint_hit &= ~DBGBP0; }

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

189

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

dbg_Sseettb_rberaekapkopionitntto_ttyripgeg_etroo_ninasdtdr_reasdsdrm_amtacthch(0);

bFroeragkeptoithnat_t hbirtea&k=po~iDnBtGwBPa0s;set
}

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

190

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

dbg_Sseettb_rberaekapkopionitntto_ttyripgeg_etroo_ninasdtdr_reasdsdrm_amtacthch(0);

bFroeragkeptoithnat_t hbirtea&k=po~iDnBtGwBPa0s;set
}

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

191

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

dbg_Sseettb_rberaekapkopionitntto_ttyripgeg_etroo_ninasdtdr_reasdsdrm_amtacthch(0);

bFroeragkeptoithnat_t hbirtea&k=po~iDnBtGwBPa0s;set
}

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

192

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

dbg_Sseettb_rberaekapkopionitntto_ttyripgeg_etroo_ninasdtdr_reasdsdrm_amtacthch(0);

bFroeragkeptoithnat_t hbirtea&k=po~iDnBtGwBPa0s;set
}

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

193

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit

dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);

} eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

dbg_Sseettb_rberaekapkopionitntto_ttyripgeg_etroo_ninasdtdr_reasdsdrm_amtacthch(0);

bFroeragkeptoithnat_t hbirtea&k=po~iDnBtGwBPa0s;set
}

We are in

}

an endless

debugging

... }

Continue firmware execution

loop

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

194

Handling Breakpoints

Address Mismatch Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HanWdlreiteBrceoadkepotionhta:ndle the breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set dbg_Sseettb_rberaekapkopionitntto_ttyripgeg_etroo_ninasdtdr_reasdsdrm_amtacthch(0); bFroeragkeptoithnat_t hbirtea&k=po~iDnBtGwBPa0s;set
}
}

Abort Mode System Mode

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

195

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints

if (dbg_is_breakpoint_enabled(0)) {

if (dbg_triggers_on_breakpoint_address (0, trace->pc)) {

// Handle Breakpoint:

breakpoint_hit |= DBGBP0; dbg_set_breakpoint_type_to_instr_addr_mismatch(0); } else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }
... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

196

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (dbg_triggers_on_breakpoint_address (0, trace->pc)) {

// Handle Breakpoint:

breakpoint_hit |= DBGBP0; dbg_set_breakpoint_type_to_instr_addr_mismatch(0); } else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }
... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

197

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// Handle Breakpoint:

breakpoint_hit |= DBGBP0; dbg_set_breakpoint_type_to_instr_addr_mismatch(0); } else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }
... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

198

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpoint_hit |= DBGBP0; dbg_set_breakpoint_type_to_instr_addr_mismatch(0); } else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }
... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

199

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit
dbg_set_breakpoint_type_to_instr_addr_mismatch(0);
} else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }
... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

200

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);
} else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }
... }

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

201

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);
} else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

202

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);
} else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

203

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);
} else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

204

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);
} else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

205

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0);
} else if (breakpoint_hit & DBGBP0) {

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

206

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

// Handle Breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

207

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_set_breakpoint_for_addr_mismatch(0, trace->pc); } }

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

208

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

209

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

210

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

211

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

212

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

213

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

214

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

215

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

216

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

217

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

218

Handling Breakpoints

Single-Stepping Implementation Breakpoint triggers multiple times
ToDos to Create DIY Debugger
· Stay in Abort Mode  · Save Register State to Abort Mode Stack 
· Initialize ABT Stack Pointer  · Analyze handle_exceptions function 
· Fix LR/SP_ABT  LR/SP_SYS  · Implement a breakpoint handler 
· Handle and reset breakpoints  · Perform Single-Stepping  · Activate breakpoints
Abort Mode System Mode

void

start:

handle_pref_abort_exception(struct trace *trace) {

MOV R0, #1

fix_sp_lr(trace);

MOV R0, #3

B start

// Do for any of the four hardware breakpoints
if (dbg_is_breCahkepcokinwt_heentahbelrebdr(e0a)k)po{int is enabled

if (Cdbhge_ctkrwighgeetrhse_robn_rebarkeapkopinoitnatd_dardedsrseesqsu(a0ls,PtCr_aScYeS->pc)) {

// HWanrdilte cBordeeaktopohiannt:dle the first breakpoint

breakpRoeinmte_mhibter|=whDiBcGhBPb0re;akpoint was hit dbSge_tsbetre_abkrpeaokinptoitnott_rtigygper_toon_iandsdtrre_sasdmdris_mmiastmcahtch(0); } eClhseeckiwf h(ebtrheearkpwoeinrte_mheimt b&erDBtGhBaPt0b)re{akpoint was set

W/r/iteHacnoddlee toBrheaankpdoleintthe single-stepping breakpoint

dbg_Sseettb_rberaekapkopionitntto_ftorirg_gaedrdorn_maidsdmaretscsh(m0a,tcthrace->pc);
}
}

... }

Continue firmware execution

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

219

Activating Breakpoints
Apps Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

220

Activating Breakpoints
Apps Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

221

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

222

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

223

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

224

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

225

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

226

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

227

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

228

The DBGDSCR Register characteristics are:

Purpose

Contains status and control information about the debug unit.

Usage constraints See DTR access mode on page 12-18.

Activating Breakpoints Configurations
Attributes

Available in all processor configurations. See Table 12-10.

Figure 12-5 shows the DBGDSCR bit assignments.

Apps 31 30 29 28 27 26 25 24 23 22 21 20 19 18

16 15 14 13 12 11 10 9 8 7 6 5

210

MOE

Linux KernReeselrved Discard imprecise
Interface to aHboort st DTR access

Core halted Core restarted Sticky precise abort Sticky imprecise abort Sticky Undefined

Reserved

Reserved

InstrCompl-l

DbgAck

PipeAdv

IntDis

ROMEthernet-to-WDDi-TTRRRFTRiAXXffBuuMllll-r-ll idge

Comms ARM

Reserved

Halting debug-mode

DTRTXfull

Monitor debug-mode

ARM MicrocoDTnRRtXrfoullller Reserved
MAC SublaAyReMr MCoarntaegxe-Rm4ent EnFtigiutrye 12-5 DBGDSCR Register bit assignments

Table 12-D10e(shMbowuLsgtMheCDEoB)GreDSCR bit assignments.

Table 12-10 DBGDSCR Register bit assignments

Bits NLaomwe Level HFuancrtidonware Control

[31]

-

RAZ on reads, SBZP on writes.

[30]

DTRRXfull

The DTRRXfull flag:

Physical Layer 0 = Read-DTR, DBGDTRRX is empty. This is the reset value

1 = Read-DTR, DBGDTRRX is full.

When set, this flag indicates to the processor that there is data available to read from the

DBGDTRRX. It is automatically set on writes to the DBGDTRRX by the debugger, and

is cleared when the processor reads the DBGDTRRX over the CP14 interface. If the flag

Matthias Schulz | SisEnoEt Mset,OreaOds f|romTtUhe DDBaGDrmTRRsXtaredtutrn|anDUnIpYredAicRtabMle vaDluee.bugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

229

To which addresses are

Activating

Breakpoints

the debugging registers mapped?

Apps
Linux Kernel Interface to Host

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

230

Apps
Linux Kernel Interface to Host

Memory Map

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

231

Apps
Linux Kernel Interface to Host

Memory Map

ROM

0x00000000

0x000A0000

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

232

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Memory Map

ROM

0x00000000

0x000A0000

RAM

0x00180000 0x00240000

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

233

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM

0x00000000

0x000A0000

RAM

0x00180000
0x00240000 0x18000000

Memory Mapped Peripherals

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

234

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM
RAM
Memory Mapped Peripherals

0x00000000
0x000A0000 0x00180000
0x00240000 0x18000000 0x???????? 0x????????

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

235

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM
RAM
Memory Mapped Peripherals

0x00000000
0x000A0000 0x00180000
0x00240000 0x18000000 0x???????? 0x????????

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

236

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM
RAM
Memory Mapped Peripherals

0x00000000
0x000A0000 0x00180000
0x00240000 0x18000000 0x???????? 0x????????

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

237

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM
RAM
Memory Mapped Peripherals

0x00000000
0x000A0000 0x00180000
0x00240000 0x18000000 0x???????? 0x????????

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

238

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM
RAM
Memory Mapped Peripherals

0x00000000
0x000A0000 0x00180000
0x00240000 0x18000000 0x18007000 0x18007FFC

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

 To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

239

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM
RAM
Memory Mapped Peripherals

0x00000000
0x000A0000 0x00180000
0x00240000 0x18000000 0x18007000 0x18007FFC

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

 To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

240

Reminder: We need to unlock debug registers!
Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Memory Map

ROM
RAM
Memory Mapped Peripherals

0x00000000
0x000A0000 0x00180000
0x00240000 0x18000000 0x18007000 0x18007FFC

0x????????

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

 To which addresses are the debugging registers mapped?

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

241

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

242

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host

Initialize Hardware

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

243

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host

Initialize Hardware Enable Interrupts

ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re
Low Level Hardware Control
Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

244

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge

Initialize Hardware
Enable Interrupts Go to Sleep
 Wait for Interrupts

ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

245

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Initialize Hardware
Enable Interrupts Go to Sleep
 Wait for Interrupts

 Send IOCTL

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

246

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Initialize Hardware Enable Interrupts
Go to Sleep  Wait for Interrupts
Wake up to handle IOCTL

 Send IOCTL

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

247

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Initialize Hardware Enable Interrupts
Go to Sleep  Wait for Interrupts
Wake up to handle IOCTL

 Send IOCTL  Handle Response

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

248

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Initialize Hardware Enable Interrupts
Go to Sleep  Wait for Interrupts
Wake up to handle IOCTL

 Send IOCTL
 Handle Response  Send IOCTL

Low Level Hardware Control Physical Layer

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

249

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Initialize Hardware Enable Interrupts
Go to Sleep  Wait for Interrupts
Wake up to handle IOCTL
Wake up to handle IOCTL:
DBGLAR = 0xC5ACCE55; // unlock debug registers

 Send IOCTL
 Handle Response  Send IOCTL

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

250

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Initialize Hardware Enable Interrupts
Go to Sleep  Wait for Interrupts
Wake up to handle IOCTL
Wake up to handle IOCTL:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

 Send IOCTL
 Handle Response  Send IOCTL

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

251

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution
Initialize Hardware Enable Interrupts
Go to Sleep  Wait for Interrupts
Wake up to handle IOCTL
Wake up to handle IOCTL:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Events

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

 Send IOCTL

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

 Handle Response  Send IOCTL
Why can`t we access the debug registers? Is the debug core even available?
252

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host

Initialize Hardware

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Why can`t we access the debug registers? Is the debug core even available?
253

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host

Initialize Hardware

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer
Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.
Why can`t we access the debug registers? Is the debug core even available?
254

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

255

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

256

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge
ARM Microcontroller MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity
De(MbuLgMCEo)re

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

257

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

258

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

259

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

260

Accessing Debug Core Reminder: We need to
unlock debug registers!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

261

Accessing Debug Core Runelmocinkddeerb: uWgerengeiestdetros!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

262

Accessing Debug Core Runelmocinkddeerb: uWgerengeiestdetros!

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control   Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

263

Accessing Debug Core Runelmocinkddeerb: uWgerengeiestdetros!

Apps Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control   Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

264

Accessing Debug Core Runelmocinkddeerb: uWgerengeiestdetros!

Apps Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control   Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

265

Accessing Debug Core Runelmocinkddeerb: uWgerengeiestdetros!

Apps Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control   Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

266

Accessing Debug Core Runelmocinkddeerb: uWgerengeiestdetros!

Apps Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer


Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

267

Accessing Debug Core Runelmocinkddeerb: uWgerengeiestdetros!

Apps

Firmware Execution

Events

Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

ARM Microcontroller

MAC

SublaAyReMr MCoarntaegxe-Rm4ent Entity

This instruction disabled the debugging core

De(MbuLgMCEo)re

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Low Level Hardware Control Physical Layer


Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

268

Accessing Debug Core

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

269

Accessing Debug Core

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 
sub_184968(v2, 5, 16, 0);

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

270

Accessing Debug Core

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 
sub_184968(v2, 5, 16, 0);

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware crashes 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

271

Accessing Debug Core

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 
sub_184968(v2, 5, 16, 0);

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

Why can`t we access the debug registers? Is the debug core even available?

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

272

Accessing Debug Core

Apps
Linux Kernel Interface to Host
ROMEthernet-to-Wi-RFiABMridge ARM Microcontroller
MAC SublaAyReMr MCoarntaegxe-Rm4ent Entity De(MbuLgMCEo)re
Low Level Hardware Control Physical Layer

Firmware Execution

Events

Initialize Hardware
Hook c_main call:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 
sub_184968(v2, 5, 16, 0);

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Add code before enabling interrupts:
DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

We managed to reactivate access to the debugging core .

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

273

Accessing Debug Core

Apps

Firmware Execution

Events

Linux Kernel

Initialize Hardware

ToDos toInCterrefaacteetoDHIoYstDebugger

Hook c_main call:

· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack 

DBGLAR = 0xC5ACCE55; // unlock debug registers
Firmware keeps running 

· AnalyzAeRhManMdilcero_ceoxnctreopllteirons function 

· MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy

sub_184968(v2, 5, 16, 0);

· HandlDee(aMbnudLgMrCeEso)eret breakpoints 

· Perform Single-Stepping 

Add code before enabling interrupts:

· AcLtiovwateLebvreelaHkaprodinwtasre Control

DBGLAR = 0xC5ACCE55; // unlock debug registers

Physical Layer

FirmFiwrmarweakreeeCprsarsuhnensing 

Somewhen in between access to debug core breaks

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

We managed to reactivate access to the debugging core .

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

274

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control

// Called by c_main_hook void set_debug_registers(void) {
dbg_unlock_debug_registers(); dbg_disable_breakpoint(0); dbg_disable_breakpoint(1); dbg_disable_breakpoint(2); dbg_disable_breakpoint(3); dbg_enable_monitor_mode_debugging();
dbg_set_breakpoint_for_addr_match(0, 0x126f0);
dbg_set_watchpoint_for_addr_match(0, 0x1FC2A4); }

Physical Layer

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

275

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

// Called by c_main_hook void set_debug_registers(void) {
dbg_unUlonclko_cdkeabcucge_srsetgoisdteebrusg(g)i;ng registers
dbg_disable_breakpoint(0); dbg_disable_breakpoint(1); dbg_disable_breakpoint(2); dbg_disable_breakpoint(3); dbg_enable_monitor_mode_debugging();
dbg_set_breakpoint_for_addr_match(0, 0x126f0);
dbg_set_watchpoint_for_addr_match(0, 0x1FC2A4); }
/* DBGLAR - Lock Access Register */ #define DBGLAR (*(volatile int *) (DBGBASE + 0xFB0)) #define DBGLAR_UNLOCK_CODE (0xC5ACCE55)
#define dbg_unlock_debug_registers() do { \ DBGLAR = DBGLAR_UNLOCK_CODE; \
} while (0)

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

276

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

// Called by c_main_hook void set_debug_registers(void) {
dbg_unUlonclko_cdkeabcucge_srsetgoisdteebrusg(g)i;ng registers
dbg_disable_breakpoint(0);
ddbbgg__ddiiDssiaasbballbeele__bbarrleel aafokkppuooriihnnattr((d12w));;are breakpoints
dbg_disable_breakpoint(3); dbg_enable_monitor_mode_debugging();
dbg_set_breakpoint_for_addr_match(0, 0x126f0);
dbg_set_watchpoint_for_addr_match(0, 0x1FC2A4); }

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

#define dbg_disable_breakpoint(number) do { \ DBGBCR ## number = UPDATE_DBG_REG(DBGBCR ## number, \ GET_DBG_MASK(DBGBCR_E), SET_DBG_VALUE(DBGBCR_E, \ DBGBCR_E_DISABLED)); \
} while (0)

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

277

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

// Called by c_main_hook void set_debug_registers(void) {
dbg_unUlonclko_cdkeabcucge_srsetgoisdteebrusg(g)i;ng registers
dbg_disable_breakpoint(0);
ddbbgg__ddiiDssiaasbballbeele__bbarrleel aafokkppuooriihnnattr((d12w));;are breakpoints
dbg_disable_breakpoint(3);
dbg_enableE_nmaobnlietomro_mnoitdoer_-ddeebbuugggimnog(d)e;
dbg_set_breakpoint_for_addr_match(0, 0x126f0);
dbg_set_watchpoint_for_addr_match(0, 0x1FC2A4); }
#define dbg_enable_monitor_mode_debugging() do { \ DBGDSCR = UPDATE_DBG_REG(DBGDSCR, \ GET_DBG_MASK(DBGDSCR_MDBGen), \ SET_DBG_VALUE(DBGDSCR_MDBGen, \ DBGDSCR_MDBGen_ENABLED)); \
} while (0)

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

278

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

// Called by c_main_hook void set_debug_registers(void) {
dbg_unUlonclko_cdkeabcucge_srsetgoisdteebrusg(g)i;ng registers
dbg_disable_breakpoint(0);
ddbbgg__ddiiDssiaasbballbeele__bbarrleel aafokkppuooriihnnattr((d12w));;are breakpoints
dbg_disable_breakpoint(3);
dbg_enableE_nmaobnlietomro_mnoitdoer_-ddeebbuugggimnog(d)e;
dbgS_estetb_rberaekapkopionitnatt_bfeorg_inandidnrg_moaftpcrhin(0tf,fu0nx1c2ti6ofn0);
dbg_set_watchpoint_for_addr_match(0, 0x1FC2A4); }

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

#define dbg_set_breakpoint_for_addr_match(number, address) do { \ DBGBCR ## number = 0x0; \ DBGBVR ## number = (address) & DBGBVR_ADDRMASK; \ DBGBCR ## number = \ SET_DBG_VALUE(DBGBCR_BT, DBGBCR_BT_UNLINKED_INSTR_ADDR_MATCH) | \ SET_DBG_VALUE(DBGBCR_MASK, DBGBCR_MASK_NO_MASK) | \ SET_DBG_VALUE(DBGBCR_E, DBGBCR_E_ENABLED) | \ SET_DBG_VALUE(DBGBCR_SSC_HMC_PMC, DBGBCR_SSC_HMC_PMC__PL0_SUP_SYS) | \ SET_DBG_VALUE(DBGBCR_BAS, GET_BAS_FOR_THUMB_ADDR(address)); \
} while (0)

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

279

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

// Called by c_main_hook void set_debug_registers(void) {
dbg_unUlonclko_cdkeabcucge_srsetgoisdteebrusg(g)i;ng registers
dbg_disable_breakpoint(0);
ddbbgg__ddiiDssiaasbballbeele__bbarrleel aafokkppuooriihnnattr((d12w));;are breakpoints
dbg_disable_breakpoint(3);
dbg_enableE_nmaobnlietomro_mnoitdoer_-ddeebbuugggimnog(d)e;

CortexTM -R 4

and

Cortex-R4F Revision: r1p4

Technical Reference Manual

dbgS_estetb_rberaekapkopionitnatt_bfeorg_inandidnrg_moaftpcrhin(0tf,fu0nx1c2ti6ofn0); } dbg_setS"_e%wtasmt: ceBhmrpoooairdynctow_mfaotScrhD_paPdoCdiMnrt_DmoaCntDcaChd(dd0rr,eivse0srxo"1fFC2A4);

Copyright © 20A0R6M-20D1D1IA0R36M3GLim(IiDte0d4.1A1l1l 1ri)ghts reserved.

#define dbg_set_watchpoint_for_addr_match(number, address) do { \ DBGWCR ## number = 0x0; \ DBGWVR ## number = (address) & DBGWVR_ADDRMASK; \ DBGWCR ## number = \ SET_DBG_VALUE(DBGWCR_WT, DBGWCR_WT_UNLINKED_DATA_ADDR_MATCH) | \ SET_DBG_VALUE(DBGWCR_MASK, DBGWCR_MASK_NO_MASK) | \ SET_DBG_VALUE(DBGWCR_E, DBGWCR_E_ENABLED) | \ SET_DBG_VALUE(DBGWCR_SSC_HMC_PAC, DBGWCR_SSC_HMC_PAC__ALL) | \ SET_DBG_VALUE(DBGWCR_LSC, DBGWCR_LSC_MATCH_ALL) | \ SET_DBG_VALUE(DBGWCR_BAS_4BIT, 0xF); \
} while (0)

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

280

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

281

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

282

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

283

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

284

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

285

Activating Breakpoints

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

286

Activating Breakpoints Why did it not trigger on other printf calls?

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasre Control
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

287

Activating Breakpoints Why did it not trigger on other printf calls?

Apps
Linux Kernel
ToDos toInCterrefaacteetoDHIoYstDebugger
· Stay in Abort Mode  · SaR·vOeMEIRtnheitegiraisnltieezter-tSAotBa-WTteSi-ttRFaoiAcABkMbrPiodorgitneMterode Stack  · AnalyzAeRhManMdilcero_ceoxnctreopllteirons function  · MImA·pCleSFmuixbeLlnaARytR/eaSMrPbM_CrAeoaaBrnktTaepgxoe-iRmnL4tReh/nSatPnE_dnSlteYirtSy
· HandlDee(aMbnudLgMrCeEso)eret breakpoints  · Perform Single-Stepping  · AcLtiovwateLebvreelaHkaprodinwtasreControl
Physical Layer

Set breakpoint at beginning of printf function
Set memory watchpoint on address of "%s: Broadcom SDPCMD CDC driver"
RTE (USB-SDIO-CDC) 6.37.32.RC23.34.43 (r639704) on BCM4339 r1 @ 37.4/161.3/161.3MHz 000000.010 WP hit pc=00012b3a 000000.013 WP hit pc=00012b3a 000000.010 sdpcmdcdc0: Broadcom SDPCMD CDC driver 000000.141 reclaim section 0: Returned 31688 bytes to the heap 000000.189 nexmon_ver: 63fb-dirty-14 000000.192 wl_nd_ra_filter_init: Enter.. 000000.196 TCAM: 256 used: 198 exceed:0 000000.200 WP hit pc=000126c2 000000.203 reclaim section 1: Returned 71844 bytes to the heap 000000.208 BP0 step 0: pc=000126f0 *r1=sdpcmd_dpc 000000.213 BP0 step 1: pc=000126f2 000000.216 BP0 step 2: pc=000126f4 000000.219 BP0 step 3: pc=000126f6 000000.223 BP0 step 4: pc=000126fa 000000.226 BP0 single-stepping done 000000.229 sdpcmd_dpc: Enable 000000.234 wl0: wlc_bmac_ucodembss_hwcap: Insuff mem for MBSS: templ memblks 192 fifo ... 000000.249 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.295 wl0: wlc_enable_probe_req: state down, deferring setting of host flags 000000.303 wl0: wlc_enable_probe_req: state down, deferring setting of host flags

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

288

Run the Debugger on Your Own!
.org

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

289

Run the Debugger on Your Own!

.org
Clone repository

· buildtools (e.g., compiler) · firmwares (e.g., for BCM4339) · patches
· <chip> · bcm4339
· <firmware version> · 6_37_34_43
· <patch name> · nexmon (monitormode + frame injection) ·... · Makefile · setup_env.sh ·...

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

290

Run the Debugger on Your Own!

.org/debugger

.org
Clone repository

· buildtools (e.g., compiler) · firmwares (e.g., for BCM4339) · patches
· <chip> · bcm4339
· <firmware version> · 6_37_34_43
· <patch name> · nexmon (monitormode + frame injection) ·... · Makefile · setup_env.sh ·...

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

291

Run the Debugger on Your Own!

.org/debugger
Clone repository
· src · patch.c (basic nexmon initialization) · debugger_base.c (common patches) · debugger.c (particular implementation) ·...
· Makefile (build and install patch) · patch.ld (linker file to place patches) ·...

.org
Clone repository
· buildtools (e.g., compiler) · firmwares (e.g., for BCM4339) · patches
· <chip> · bcm4339
· <firmware version> · 6_37_34_43
· <patch name> · nexmon (monitormode + frame injection) ·... · Makefile · setup_env.sh ·...

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

292

Run the Debugger on Your Own!

.org/debugger
Clone repository
· src · patch.c (basic nexmon initialization) · debugger_base.c (common patches) · debugger.c (particular implementation) ·...
· Makefile (build and install patch) · patch.ld (linker file to place patches) ·...
nexmon> make && source setup_env.sh nexmon> cd patches/bcm4339/ 6_37_34_43/debugger nexmon> make install-firmware

.org
Clone repository
· buildtools (e.g., compiler) · firmwares (e.g., for BCM4339) · patches
· <chip> · bcm4339
· <firmware version> · 6_37_34_43
· <patch name> · nexmon (monitormode + frame injection) ·... · Makefile · setup_env.sh ·...

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

293

Firmware Patching

patch.asm contains patches written in ARM assembler

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

294

Firmware Patching

Assembler assembles source files

patch.asm contains patches written in ARM assembler

patch.bin contains machine code binary files of patches

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

295

Firmware Patching

Assembler assembles source files

firmware.bin contains original firmware for Wi-Fi chip

patch.asm contains patches written in ARM assembler

patch.bin contains machine code binary files of patches

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

296

Firmware Patching

Assembler assembles source files
patch.asm contains patches written in ARM assembler

firmware.bin contains original firmware for Wi-Fi chip

Patching Tools Python based collection of firmware patching tools patch.bin contains machine code binary files of patches

patched_firmware.bin contains patched firmware for Wi-Fi chip

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

297

Firmware Patching

Assembler assembles source files
patch.asm contains patches written in ARM assembler

firmware.bin contains original firmware for Wi-Fi chip

Patching Tools Python based collection of firmware patching tools patch.bin contains machine code binary files of patches

patched_firmware.bin contains patched firmware for Wi-Fi chip

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

298

C Based Firmware Patching
C files contain source code for patches

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

299

C Based Firmware Patching

Compiler
C files contain source code for patches

Object files contain compiled functions and variables with partially unresolved symbols

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

300

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

nexmon.pre contains extracted address information

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

301

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

C

nexmon.pre contains extracted address information

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

302

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

C

nexmon.pre contains extracted address information

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

303

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

C

nexmon.pre contains extracted address information

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

304

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

C
nexmon.pre contains extracted address information

__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

305

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

C
nexmon.pre contains extracted address information

__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

306

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

C
nexmon.pre contains extracted address information

__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

307

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols

nexmon.pre contains extracted address information

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

308

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols
Linker files contain address information to place functions

nexmon.pre contains extracted address information

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

309

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols
Linker files contain address information to place functions

nexmon.pre contains extracted address information

Makefiles files contain commands to extract functions and variables from linker output and insert them into the firmware

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

310

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols
Linker files contain address information to place functions

Linker

nexmon.pre contains extracted address information

Makefiles files contain commands to extract functions and variables from linker output and insert them into the firmware

patch.elf file contains placed functions and variables with resolved symbols

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

311

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols
Linker files contain address information to place functions

Linker

firmware.bin original firmware file

nexmon.pre contains extracted address information

Makefiles files contain commands to extract functions and variables from linker output and insert them into the firmware

patch.elf file contains placed functions and variables with resolved symbols

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

312

C Based Firmware Patching

Compiler

C files contain source code for patches

Nexmon GCC Plugin

Object files contain compiled functions and variables with partially unresolved symbols
Linker files contain address information to place functions

Linker

firmware.bin original firmware file
Makefile

nexmon.pre contains extracted address information

Makefiles files contain commands to extract functions and variables from linker output and insert them into the firmware

patch.elf file contains placed functions and variables with resolved symbols

patched_fw.bin modified firmware file

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

313

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

314

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);
RAM of a BCM4339 in Nexus 5:

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

315

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);
RAM of a BCM4339 in Nexus 5: free

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

316

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);
RAM of a BCM4339 in Nexus 5: free

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

317

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);
RAM of a BCM4339 in Nexus 5: free
RAM of most other BCM chips:

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

318

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);
RAM of a BCM4339 in Nexus 5: free
RAM of most other BCM chips:

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

319

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);
RAM of a BCM4339 in Nexus 5: free
RAM of most other BCM chips:

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

320

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

RAM of a BCM4339 in Nexus 5: free
RAM of most other BCM chips:

D11 firmware D11 firmware

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

321

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

RAM of a BCM4339 in Nexus 5:

free

D11 compD.1fw1 firmwarefree

RAM of most other BCM chips:

D11 comDp.1f1wfirmwarefree

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

322

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

RAM of a BCM4339 in Nexus 5:

free

D11 compD.1fw1 firmwarefree

RAM of most other BCM chips:

D11 comDp.1f1wfirmwarefree

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

323

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

RAM of a BCM4339 in Nexus 5:

free

D11 compD.1fw1 firmwarefree

RAM of most other BCM chips:

generally assigned to heap D11 comDp.1f1wfirmwarefree

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

324

Patch Placement
C
#pragma NEXMON targetregion "patch"
void target_function_name(int a) { so_something(a);
}
__attribute__((at(0x2220A, "flashpatch", CHIP_..., FW_...))) BLPatch(hook_name, target_function_name);

RAM of a BCM4339 in Nexus 5:

free

D11 compD.1fw1 firmwarefree

RAM of most other BCM chips:

generally assigned to heap D11 comDp.1f1wfirmwarefree

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

325

Applications using Nexmon

Massive Reactive Smartphone-Based Jamming using Arbitrary Waveforms and Adaptive
Power Control, Best Paper at WiSec'17

Nexmon Penetration Testing App with Monitor Mode, Frame
Injection, Airodump View and Wireshark Dissection, Google Play Store

Compressive MillimeterWave Sector Selection in
Off-the-Shelf IEEE 802.11ad Devices,
CoNEXT'17

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

Source Code and Results available at https://nexmon.org
326

Third-Party Applications using Nexmon

Reversing IoT: Xiaomi Ecosystem Gain cloud independence and additional functionality by firmware modification, Recon BRX `18

Breaking Fitness Records without Moving: Reverse Engineering and Spoofing Fitbit,
RAID`18

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

100 steps at a time
327

More Exciting Nexmon Results

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

My PhD defense February 26, 2018 at 1 pm @ TU Darmstadt, Germany
328

Matthias Schulz Department of Computer Science
SEEMOO Mornewegstr. 32 64293 Darmstadt/Germany mschulz@seemoo.tu-darmstadt.de

Twitter

@nexmon_dev

Phone +49 6151 16-25478

Fax

+49 6151 16-25471

www.seemoo.tu-darmstadt.de

Matthias Schulz | SEEMOO | TU Darmstadt | DIY ARM Debugger for Wi-Fi Chips

329

